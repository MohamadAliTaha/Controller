#!/usr/bin/env python

import threading
from time import sleep

import rospy
from mcu_control.msg._Currents import Currents
from mcu_control.msg._ThermistorTemps import ThermistorTemps
from mcu_control.msg._Voltage import Voltage
from PyQt5 import QtCore, QtGui, QtWidgets

from pages.arm import Arm
from pages.controller import Controller
from pages.pds import Pds
from pages.science import Science
from useful import Header, Queue


class Worker(threading.Thread):
    def __init__(self, threadID: int, name: str):
        threading.Thread.__init__(self)
        self.threadID: int = threadID
        self.name: str = name
        self.daemon: bool = True  # close with parent
        self.command_queue = Queue(10)

    def run(self):
        while not rospy.is_shutdown():
            try:
                if self.command_queue.get_list():
                    self.command_queue.get_list()[0][0](
                        *self.command_queue.get_list()[0][1]
                    ) if self.command_queue.get_list()[0][1] else self.command_queue.get_list()[0][0]()
                    self.command_queue.get_list().pop(0)
                    sleep(0.01)
            except:
                pass


class Ros_thread(threading.Thread):
    def __init__(self, threadID: int, name: str):
        threading.Thread.__init__(self)
        self.threadID: int = threadID
        self.name: str = name
        self.daemon: bool = True
        self.subbed_topics = []

        # each item in this tuple is a collection of all topics needed for the according page
        # each item (topic) in said collection is a tuple that contains the arguments needed for the Subscriber method
        # the lambda function used appends the passed function and its args to the Worker thread's Queue so they are run in order
        self.topics = (
            [
                (
                    "wheel_motor_currents",
                    Currents,
                    lambda data: worker.command_queue.append((controller.display_currents, [data])),
                ),
            ],  # wheel topics
            [
                (
                    "arm_motor_currents",
                    Currents,
                    lambda data: worker.command_queue.append((arm.display_currents, [data])),
                ),
            ],  # arm topics
            [
                (
                    "wheel_motor_currents",
                    Currents,
                    lambda data: worker.command_queue.append((pds.display_wheel_currents, [data])),
                ),
                (
                    "arm_motor_currents",
                    Currents,
                    lambda data: worker.command_queue.append((pds.display_arm_currents, [data])),
                ),
            ],  # pds topics
            [],  # science topics
        )

    def handle_tab_change(self, page_index: int):
        """Called on tab change to unsub to old topics and
        replace them with the ones needed for the new tab"""

        for i in reversed(range(len(self.subbed_topics))):
            self.subbed_topics[i].unregister()  # unsubs to all previous topics
            self.subbed_topics.pop()
        worker.command_queue.clear()
        for topic in self.topics[page_index]:
            self.subbed_topics.append(rospy.Subscriber(*topic, queue_size=1))  # subs to new page topics

    def run(self):
        # these 2 topics are needed for all tabs since they are used outside the tab widget
        self.battery_temps = rospy.Subscriber(
            "battery_temps",
            ThermistorTemps,
            lambda data: worker.command_queue.append([header.update_temps, [data]]),
            queue_size=1,
        )
        self.battery_voltage = rospy.Subscriber(
            "battery_voltage",
            Voltage,
            lambda data: worker.command_queue.append([header.update_voltage, [data]]),
            queue_size=1,
        )

        self.handle_tab_change(
            0
        )  # 0 just signifies the topics of the first tab since this is the first tab displayed


class MainWindowClass(QtWidgets.QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.pressed_keys: list = []
        self.page: str = ""

    def keyPressEvent(self, event: QtGui.QKeyEvent) -> None:
        if event.isAutoRepeat():
            return  # this prevents the press and release events from continuously firing

        self.page = tab_widget.currentWidget().objectName()
        key: str = event.text()

        if self.page == "controller" and not controller.log_browser.line_edit.hasFocus():
            keys = ["d", "w", "a", "s"]
            if key in keys:
                self.pressed_keys.append(key)
                controller.set_page_buttons(False)
                for i in range(int(len(keys) / 2)):
                    if key == keys[i]:
                        controller.velocity[i] += controller.throttle
                    elif key == keys[i + int(len(keys) / 2)]:
                        controller.velocity[i] -= controller.throttle
                controller.send_velocity()
        elif self.page == "arm" and not arm.log_browser.line_edit.hasFocus():
            keys = ["w", "e", "r", "t", "y", "u", "s", "d", "f", "g", "h", "j"]
            if key in keys:
                self.pressed_keys.append(key)
                arm.manual_controls_button.setChecked(True)
                arm.set_page_buttons(False)
                for i in range(int(len(keys) / 2)):
                    if key == keys[i]:
                        arm.speeds[i] += arm.speed_multiplier
                    elif key == keys[i + int(len(keys) / 2)]:
                        arm.speeds[i] -= arm.speed_multiplier
                arm.send_speeds()

        return super().keyPressEvent(event)

    def keyReleaseEvent(self, event: QtGui.QKeyEvent) -> None:
        if event.isAutoRepeat():
            return

        key: str = event.text()

        try:
            if self.page == "controller" and not controller.log_browser.line_edit.hasFocus():
                keys = ["d", "w", "a", "s"]
                if key in keys:
                    self.pressed_keys.remove(key)
                    for i in range(int(len(keys) / 2)):
                        if key == keys[i]:
                            controller.velocity[i] -= controller.throttle
                        elif key == keys[i + int(len(keys) / 2)]:
                            controller.velocity[i] += controller.throttle
                    controller.send_velocity()

                    if not any(self.pressed_keys):
                        controller.set_page_buttons(True)
            elif self.page == "arm" and not arm.log_browser.line_edit.hasFocus():
                keys = ["w", "e", "r", "t", "y", "u", "s", "d", "f", "g", "h", "j"]
                if key in keys:
                    self.pressed_keys.remove(key)
                    for i in range(int(len(keys) / 2)):
                        if key == keys[i]:
                            arm.speeds[i] -= arm.speed_multiplier
                        elif key == keys[i + int(len(keys) / 2)]:
                            arm.speeds[i] += arm.speed_multiplier
                    arm.send_speeds()

                    if not any(self.pressed_keys):
                        arm.set_page_buttons(True)
        except ValueError:
            pass

        return super().keyReleaseEvent(event)


if __name__ == "__main__":
    import sys

    rospy.init_node("gui_controller")

    worker = Worker(1, "worker")

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = MainWindowClass()
    MainWindow.setObjectName("MainWindow")

    # used for adaptive window size, gets the screen size of the current display
    screen = QtWidgets.QDesktopWidget().screenGeometry(-1)
    width: int = screen.width()  # 1920 x 1080 for me
    height: int = screen.height()
    MainWindow.resize(width, height)
    MainWindow.setStyleSheet("background-color: rgb(43, 52, 59);\n" "color: rgb(238, 238, 236);")

    controller_tab = QtWidgets.QWidget()
    arm_tab = QtWidgets.QWidget()
    pds_tab = QtWidgets.QWidget()
    science_tab = QtWidgets.QWidget()

    controller = Controller(width, height, controller_tab, MainWindow)
    arm = Arm(width, height, arm_tab, MainWindow)
    pds = Pds(width, height, pds_tab, MainWindow)
    science = Science(width, height, science_tab, MainWindow)

    header = Header(width, height, MainWindow)
    header.setup()

    tab_widget = QtWidgets.QTabWidget(MainWindow)
    tab_widget.setGeometry(QtCore.QRect(0, height / 15.43, width, 0.87 * height))

    controller_tab.setObjectName("controller")
    arm_tab.setObjectName("arm")
    pds_tab.setObjectName("pds")
    science_tab.setObjectName("science")

    tab_widget.addTab(controller_tab, "Controller")
    tab_widget.addTab(arm_tab, "Arm")
    tab_widget.addTab(pds_tab, "PDS")
    # tab_widget.addTab(science_tab, "Science")

    ros_thread = Ros_thread(2, "ros-thread")
    tab_widget.currentChanged.connect(ros_thread.handle_tab_change)

    MainWindow.setWindowTitle("Rover Controller")
    MainWindow.show()

    ros_thread.start()
    worker.start()
    sys.exit(app.exec_())
