#!/usr/bin/env python

from mcu_control.msg._ThermistorTemps import ThermistorTemps
from mcu_control.msg._Currents import Currents
from mcu_control.msg._Voltage import Voltage
from controller_ui_file import Ui_MainWindow
from PyQt5.QtCore import QCoreApplication
from pynput import keyboard
from PyQt5 import QtWidgets
import threading
import rospy


def on_press(function, args=None):
    if not ui.line_edit.has_focus:
        function(args) if args else function()


class Key_capture_thread(threading.Thread):
    def __init__(self, threadID, name):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name

    def kill(self):
        QCoreApplication.instance().quit()
        exit()

    def run(self):
        hotkeys = {
            "<ctrl>+p": lambda: on_press(ui.ping_rover_mcu),
            "<alt>+p": lambda: on_press(ui.ping_odroid),
            "q": lambda: on_press(ui.emergency_stop),
            "l": lambda: on_press(ui.list_commands),
            "u": lambda: on_press(ui.change_throttle, "+"),
            "i": lambda: on_press(ui.change_throttle, "-"),
            
            # the following commands aren't in the on_press method 
            # because they run dispite textbox focus
            "<Enter>": ui.run_command,
            "<ctrl>+<shift>+k": self.kill,
        }

        with keyboard.GlobalHotKeys(hotkeys) as listener:
            listener.join()


class Ros_thread(threading.Thread):
    def __init__(self, threadID, name):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name

    def run(self):
        currents = rospy.Subscriber(
            "wheel_motor_currents", Currents, ui.display_currents)
        battery_temps = rospy.Subscriber(
            "battery_temps", ThermistorTemps, ui.display_temps)
        battery_voltage = rospy.Subscriber(
            "battery_voltage", Voltage, ui.display_voltage)


class Controller(Ui_MainWindow):
    def __init__(self):
        self.voltage = 0
        self.throttle = 0.50
        self.temps = ()
        self.currents = ()
        self.commands = {
            'ctrl-p': "ping rover mcu",
            'alt-p': "ping odroid",
            'q': "emergency stop all motors",
            'l': "view key commands",
        }

    def ping_rover_mcu(self):
        print("ping rover in mcu")

    def ping_odroid(self):
        print("ping odroid")

    def emergency_stop(self):
        print("emergency stop")

    def list_commands(self):
        """This method appends this program's keyboard shortcuts 
        to the UI's text browser """

        for command in self.commands:
            self.append_to_browser(f"'{command}': '{self.commands[command]}'")
        self.append_to_browser("\n")

    def change_throttle(self, change):
        """Changes the current throttle value either increasing or
        decreasing and outputs the new value to the throttle label"""

        if change == "+" and not self.throttle >= 1:
            # This weird sum is done to avoid arithmetic errors when it comes to decimals in python
            self.throttle = (self.throttle * 10 + 0.50) / 10
        elif change == "-" and not self.throttle <= 0:
            self.throttle = (self.throttle * 10 - 0.50) / 10

        self.throttle_value.setText(f"{self.throttle}")

    def display_temps(self, data):
        degree = u'\N{DEGREE SIGN}'
        self.temps = tuple(str(data).split()[1::2])
        self.temp1_label.setText(f"{self.temps[0]} {degree}C")
        self.temp2_label.setText(f"{self.temps[1]} {degree}C")
        self.temp3_label.setText(f"{self.temps[2]} {degree}C")

    def display_currents(self, data):
        self.currents = tuple(data.effort)

        self.r_front_current.setText(f"{self.currents[0]}")
        self.r_mid_current.setText(f"{self.currents[1]}")
        self.r_back_current.setText(f"{self.currents[2]}")
        self.l_front_current.setText(f"{self.currents[3]}")
        self.l_mid_current.setText(f"{self.currents[4]}")
        self.l_back_current.setText(f"{self.currents[5]}")

    def display_voltage(self, data):
        self.voltage = data.data
        self.voltage_label.setText(f"{self.voltage} V")

    def run_command(self):
        """Gets the content of the command line and tries to run it if possible"""

        command = ui.line_edit.text()
        if command.strip() != "":
            self.append_to_browser(f"{command} \n")
        ui.line_edit.clear()

    def append_to_browser(self, data):
        """Adds functionality to the append method of the browser
        like scrolling to the bottom"""

        ui.text_browser.append(str(data))
        self.text_browser.verticalScrollBar().setValue(
            self.text_browser.verticalScrollBar().maximum())

    def run_threads(self):
        "Runs the program's two threads, key capture and ros"

        keyboard_thread = Key_capture_thread(1, "key-capture-thread")
        keyboard_thread.start()
        ros_thread = Ros_thread(2, "ros-thread")
        ros_thread.start()


if __name__ == '__main__':
    import sys

    rospy.init_node("gui_controller", anonymous=True)

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()

    ui = Controller()

    ui.setupUi(MainWindow)
    ui.run_threads()

    ui.list_commands_button.clicked.connect(ui.list_commands)
    ui.stop_button.clicked.connect(ui.emergency_stop)
    ui.send_command_button.clicked.connect(ui.run_command)

    MainWindow.show()

    sys.exit(app.exec_())
